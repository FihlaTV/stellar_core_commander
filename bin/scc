#!/usr/bin/env ruby

require 'stellar_core_commander'
require 'slop'

def run
  $opts = Slop.parse(ARGV, :help => true) do
    banner 'Usage: scc -r RECIPE'

    on 'stellar-core-bin',
      'a path to a stellar-core executable (defaults to `which stellar-core`)',
      argument: true
    on 'r', 'recipe',
      'a recipe file',
      argument: true
    on 'p', 'process',
      'method for running stellar-core',
      argument: true,
      default: 'local'
    on 'w', 'wait',
      'wait for TERM signal before shutting down and cleaning up',
       argument: false,
       default: false
  end

  recipe    = load_recipe
  commander = make_commander

  #run recipe
  transactor = StellarCoreCommander::Transactor.new(commander)


  transactor.run_recipe recipe
  transactor.close_ledger

  output_results(commander.get_root_process transactor)

  if $opts[:wait]
    puts "Waiting for INT signal..."
    Signal.trap("INT"){ exit }
    sleep
  end
end


def make_commander
  opts = {
    stellar_core_bin: $opts[:"stellar-core-bin"],
  }

  StellarCoreCommander::Commander.new($opts[:"process"], opts).tap do |c|
    c.cleanup_at_exit!
  end
end

def load_recipe
  recipe = $opts[:recipe]

  if recipe.blank?
    $stderr.puts $opts
    exit 1
  end

  unless File.exist?(recipe)
    $stderr.puts "not found: #{recipe}"
    exit 1
  end

  recipe
end

def output_results(process)
  $stdout.puts process.dump_database
end

run
